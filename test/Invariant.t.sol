// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.10;

import "forge-std/Test.sol";
import "../src/libraries/Constants.sol";
import { IERC20 } from "forge-std/interfaces/IERC20.sol";
import "../src/interfaces/IAaveFlashloan.sol";
import "../src/interfaces/IMasterPlatypusV4.sol";
import "../src/interfaces/IPlatypusPool.sol";
import "../src/interfaces/IPlatypusTreasure.sol";
import "../src/interfaces/CheatCodes.sol";
import "../src/Handler.sol";

contract Invariant is Test {

    IERC20 USP = IERC20(Constants.USP);
    IERC20 USDT = IERC20(Constants.USDT);
    IERC20 LPUSDC = IERC20(Constants.LPUSDC);
    PlatypusTreasure Treasure = PlatypusTreasure(Constants.PLATYPUS_TREASURE);
    

    CheatCodes cheatCodes = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    Handler handler;

    function setUp() external {
        cheatCodes.createSelectFork("Avalanche", 26_343_613);
        handler = new Handler();
        
        bytes4[] memory selectors = new bytes4[](7);
        selectors[0] = Handler.approveUSDC.selector;
        selectors[1] = Handler.depositToPool.selector;
        selectors[2] = Handler.approveLPUSDC.selector;
        selectors[3] = Handler.depositToMater.selector;
        selectors[4] = Handler.borrowFromTreasure.selector;
        selectors[5] = Handler.emergencyWithdraw.selector;
        selectors[6] = Handler.withdraw.selector;

        // TODO mint some USDC to handler

        targetContract(address(handler));
        targetSelector(FuzzSelector({
            addr: address(handler),
            selectors: selectors
        }));
    }

    function invariant_withdrawBackingFunds() external {
        uint256 handlerBalance = USP.balanceOf(address(handler));
        PlatypusTreasure.PositionView memory Position = Treasure.positionView(address(handler), address(LPUSDC));
        uint256 limit = Position.borrowLimitUSP;

        assertEq(
            true,
            handlerBalance <= limit
        );
    }

}